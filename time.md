Переходим в Git Bash и вводим команду ssh-keygen -t ed25519 -C "электронная почта". Вместо текста «электронная почта» нужно написать почту, которую вы указывали при регистрации на GitHub.
ssh-keygen -t ed25519 -C "volo
Введена команда ssh-keygen -t ed25519 -C
Нас уведомляют о том, что происходит генерация пары открытых и закрытых ключей ed25519. То есть началось создание SSH-ключа с использованием почты, которую мы указали в команде.

Далее нам предлагают указать файл, в котором будет храниться SSH-ключ, или нажать клавишу Enter для выбора значения по умолчанию. Выбираем второй вариант: если задавать пользовательское значение расположения и названия файла, в будущем могут появиться некоторые трудности.
Генерация SSH-ключа завершена. Нас также уведомили о том, что идентификационный файл и файл с публичным ключом сохранены в директории .ssh. Дополнительно нам показали случайное изображение, созданное на основе сгенерированного ключа.

Прейдём в директорию .ssh с помощью команды cd ~/.ssh/ и убедимся, что файлы действительно там появились.
Затем введём команду ls -la, чтобы вывести содержимое директории.

cd- повертає нас в ту директорию в якій ми були до цього
Можно было написать команду ls -la ~/.ssh/

скопируем публичный (открытый) SSH-ключ, чтобы позже вставить его в специальное поле на GitHub. Для этого воспользуемся командой clip < ~/.ssh/id_ed25519.pub

Дальше нам предлагают выбрать тип ключа: Authentication Key или Signing Key. Так как нам нужен тип Authentication Key, оставляем всё без изменений. С помощью SSH-ключа можно подписывать коммиты — если бы это было нам нужно, мы бы выбрали тип Signing Key.
В последнее текстовое поле Key вставляем скопированный ключ. После этого нажимаем на кнопку Add SSH key

Проверим SSH-соединение — убедимся, что в прошлом шаге мы всё сделали верно и у нас есть связь с GitHub. Для этого мы развернём Git Bash и введём команду ssh -T git@github.com.

Далее нам сообщат, что проверить подлинность хоста GitHub пока невозможно, и попросят подтвердить, что отпечаток SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU совпадает с отпечатком открытого ключа GitHub. Отпечаток открытого ключа GitHub для ed25519 — SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. Отпечатки совпадают, а это значит, мы можем ввести в Git Bash yes и нажать клавишу Enter.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

SSH-агент — это менеджер ключей, работающий с SSH. Он хранит закрытые ключи, которые затем используются для аутентификации. SSH-агент избавляет нас от постоянного ввода пароля. Его можно сравнить с менеджером паролей, который мы используем при входе на какой либо-веб-сайт.

Сначала введём команду eval "$(ssh-agent -s)", которая запускает SSH-агент.

Затем добавим закрытый ключ в SSH-агент с помощью команды ssh-add ~/.ssh/id_ed25519. Если при генерации пары ключей SSH вы указали другое название файла, укажите в команде путь до файла с закрытым ключом.

Настраиваем автоматический запуск SSH-агента

Закроем Git Bash и остановим процесс SSH-агента через диспетчер задач либо любым другим способом. Это нужно для того, чтобы вы увидели, как работает автоматический запуск SSH-агента. После перейдём в директорию пользователя и создадим в ней два файла. Первый с названием .bashrc, а второй — .bash_profile.

Далее откроем через любой редактор кода файл .bashrc

Затем вставим в него следующий код:

env=~/.ssh/agent.env

agent_load_env () { test -f "$env" && . "$env" >| /dev/null ; }

agent_start () {
(umask 077; ssh-agent >| "$env")
    . "$env" >| /dev/null ; }

agent_load_env

agent_run_state=$(ssh-add -l >| /dev/null 2>&1; echo $?)

if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then
agent_start
ssh-add
elif [ "$SSH_AUTH_SOCK" ] && [ $agent_run_state = 1 ]; then
ssh-add
fi

unset env

Сохраняем и закрываем файл. Теперь нужно открыть файл .bash_profile

Вставим код:

test -f ~/.profile && . ~/.profile
test -f ~/.bashrc && . ~/.bashrc

Код из файла .bashrc будет запускать SSH-агент, а код из файла .bash_profile будет запускать файл .bashrc.

Плюс данного способа: вам нужно ввести кодовую фразу только один раз при первом запуске Git Bash. После она не будет запрашиваться — и так до тех пор, пока вы не перезагрузите компьютер.

//==================================================================================================================//

Изменить кодовую фразу можно с помощью команды ssh-keygen -p -f ~/.ssh/id_ed25519. Если вы указали при генерации другое название файла, а не выбрали значение по умолчанию id_ed25519, то в команде нужно указать ваше название и путь (если он тоже изменён).

После ввода команды нас попросят ввести старую кодовую фразу. Введём её и нажмём клавишу Enter.

укажем новую кодовую фразу. Введём её и снова нажмём клавишу Enter.

//===================================================================================================================//

Изначально у GPG было другое название — G10, оно появилось благодаря десятой статье Конституции ФРГ. Суть этой статьи заключается в том, что тайна переписки, почтовая и телекоммуникационная тайна неприкосновенны. В Конституции РФ есть похожая статья, под номером 23. Всё это наводит на мысль, что в погоне за безопасностью и было разработано данное программное обеспечение. Также есть ещё два вида записи названия: GnuPG и развёрнутое GNU Privacy Guard.

Программа GPG создана немецким разработчиком Вернером Кохом.

Эти статусы помогают разработчикам понять, из какого источника поступают изменения: надёжного или ненадёжного. Например, когда установлен статус Unverified, нет гарантии, что это действительно вы сделали коммит, ведь ваши данные (почту и пароль от аккаунта) легко заполучить. А вот GPG-ключ получить проблематично, но именно он и позволяет установить ту самую подпись, которая связывает автора и коммит.

Для дополнительной безопасности администраторы репозитория могут даже включить опцию, которая проверяет, что поступающие на ветку коммиты были подписанными и проверенными.

По умолчанию до включения режима Vigilant mode, или режима бдительность, есть три статуса:

Verified — коммит подписан, подпись проверена.
Unverified — коммит подписан, но подпись не удалось проверить. Скорее всего, GitHub не может распознать подпись, так как она создана вручную или неспециализированным софтом. Это редкий статус, он появляется, если вы намеренно пытаетесь сделать что-то не так, как нужно.
Статуса нет, коммит не подписан.

Генерируем пару ключей GPG

Сгенерируем пару ключей GPG. Сначала развернём Git Bash и введём команду gpg --full-generate-key

Нас уведомляют, что будут созданы новая директория .gnupg в директории пользователя, а также файл с ключами в директории .gnupg. Далее нам предлагают выбрать тип ключа. Оставим значение по умолчанию — RSA and RSA, и нажмём клавишу Enter.

Затем нас просят указать размер ключа. В значении по умолчанию задан размер 3072 бит, но мы укажем 4096, а после нажмём клавишу Enter. Чем больше размер ключа, тем он устойчивее, а его дешифровка будет занимать больше времени.

Далее нас просят указать срок действия ключа. Выберем значение по умолчанию, то есть 0. Это означает, что ключ будет действовать неограниченное количество времени. Жмём Enter и идём дальше.0

. Вам нужно ввести своё имя пользователя. Лучше указать то, которое вы прописывали при настройке Git в команде git config --global user.name.

Далее укажем электронную почту, которая привязана к GitHub, и нажмём Enter.
Поле «Комментарий» можно пропустить или указать GitHub key — оно необязательное. Мы в него ничего не будем записывать, поэтому просто нажмём Enter

Добавляем GPG-ключ в аккаунт на GitHub

Сначала введём команду gpg --list-secret-keys --keyid-format=long.

Далее скопируем идентификатор GPG-ключа. В нашем случае он такой: B32440B423383E93. У вас он также будет в строке sec, но с другими символами. Затем введём ещё одну команду, позволяющую показать ключ для вставки в GitHub — gpg --armor --export B32440B423383E93. После --export вставьте свой идентификатор.

Появился очень длинный ключ. Он начинается с -----BEGIN PGP PUBLIC KEY BLOCK-----
и заканчивается на -----END PGP PUBLIC KEY BLOCK-----.
Скопируем его полностью вместе с этим текстом. После этого перейдём в GitHub и нажмём на мини-иконку профиля.

В поле Title укажите любое название для GPG-ключа. Это примерно такое же поле, как было при добавлении SSH-ключа. А в поле Key вставьте тот самый ключ, который был в Git Bash. После этого нажимаем на зелёную кнопку Add GPG key.

Добавляем GPG-ключ в глобальный конфигурационный файл Git

Git до сих пор не знает про GPG-ключ, поэтому нужно добавить наш ключ в глобальный конфигурационный файл. Возьмём ранее выведенный идентификатор GPG-ключа B32440B423383E93. Затем введём команду в Git Bash git config --global user.signingkey B32440B423383E93

Если вы захотите использовать приложение GitHub Desktop после настройки GPG, то столкнётесь с ошибкой, из-за которой у вас не получится подписать коммит. Всё дело в том, что изначально коммиты подписываются только через терминал и с использованием опции -S, а при использовании GitHub Desktop нельзя указать опцию. Поэтому в глобальном конфигурационном файле нужно явно указать программу GPG, которая будет вызываться при использовании приложения GitHub Desktop во время создания нового коммита.

Для начала определим путь, по которому расположена программа GPG. Для этого мы введём в Git Bash команду where gpg.

Далее скорректируем путь до программы на такой: C:/Program Files/Git/usr/bin/gpg.exe. То есть заменим обратные слэши на прямые, чтобы они не вызывали проблем.

Введём команду git config --global gpg.program "C:/Program Files/Git/usr/bin/gpg.exe"

Настраиваем подписание коммитов по умолчанию

Для подписания коммита нужно вводить опцию -S в команде git commit, но это не всегда удобно, да и про неё можно просто забыть. Поэтому сейчас мы включим подписание коммитов по умолчанию. Для этого пропишем в Git Bash команду git config --global commit.gpgsign true

//================================================================================================================//

Чтобы увидеть обозначения разделов, нужно воспользоваться командой git status --short или сокращённо git status -s. Эта команда слева выводит статус, а справа — путь до файла.
Статус «M» красный
Статус «M», или Modified (модифицированный), может быть только у отслеживаемых файлов. Он появляется, когда в файл вносятся изменения. Красный цвет означает, что изменения ещё не добавлены в индекс.

Статус «M» зелёный
Статус «M» становится зелёным, когда изменения добавляются в индекс. От статуса «M» с красным цветом больше ничем не отличается.

Статус «M» зелёный и красный
Особый статус «MM» появляется, когда используется команда git add --patch или git add -p. Он означает, что в файле часть изменений добавлена в индекс, а другая — не добавлена.

Статус «D» красный
Статус «D», или развёрнуто Deleted, получает удалённый файл. Его можно получить, если вы удаляете файл вручную или использовав команду rm. В целом подходит любая команда для удаления файлов, кроме git rm.

Статус «D» зелёный
Статус «D» зелёного цвета означает, что удалённый файл был добавлен в индекс. Статус такого цвета можно получить при использовании команды git rm. Она позволяет удалить файл и сразу добавить его в индекс, чтобы потом закоммитить данное изменение.

Статус «?» красный
Статус «?», или развёрнуто Untracked (неотслеживаемый), получают новые файлы, которые были добавлены в репозиторий. При этом данные файлы не запрещены к добавлению в индекс, их можно закоммитить.

Статус «A» зелёный
Статус «A», или развёрнуто Added (добавленный), получают неотслеживаемые файлы (разрешённые к добавлению), которые были добавлены в индекс.

Статус «!» красный
Статус «!», или развёрнуто Ignored, получают файлы, которые добавлены в .gitignore. Они тоже считаются неотслеживаемыми, но в отличие от статуса ?? запрещены к добавлению в индекс. Просто так при использовании команды git status --short мы их не увидим, нужно дополнительно прописать опцию --ignored. В итоге получится такая запись: git status --short --ignored.

Статус «UU» красный
Статус «UU», или развёрнуто Unmerged (не слитый или оба модифицированы both modified), появляется во время конфликта при слиянии.

//=================================================================================================================//
В этой демонстрации мы рассмотрим базовые команды для работы с терминалом

Команда mkdir создаёт новую директорию. После неё через пробел указывается название директории.
Команда cd позволяет перейти в указанную директорию из текущей. У этой команды есть различные виды записи:

- cd — возвращает нас в домашнюю директорию. Домашняя директория — это директория пользователя, в которой содержатся все основные директории (документы, рабочий стол и так далее) и файлы с настройками;
- cd - — возвращает нас к предыдущему каталогу. Это примерно то же самое, что и команда git switch -, которая возвращала нас к предыдущей ветке. С такими командами нужно быть аккуратнее, так как можно оказаться не в той директории, в которой хотелось бы быть. Дополнительно команда cd - выводит директорию, в которую мы переместились;
- cd путь — наиболее распространённая запись, когда после cd указывается путь до нужной директории. В Windows путь лучше заключать в кавычки "", иначе Git Bash может не найти директорию;
- cd ../ или cd .. — позволяет перейти в родительскую директорию по отношению к текущей. Допустим, у нас есть директория home, в ней находится директория users, а в ней ещё одна директория — htmlacademy, она же текущая. Если мы пропишем команду cd ../ или cd .., то переместимся в директорию users, так как именно она считается родительской;
- cd ~/путь — позволяет указать путь от домашней директории. Домашняя директория обозначается как ~/. Ключевое отличие от команды cd путь в том, что cd ~/ использует абсолютный путь. Мы можем перейти в любую директорию, начиная от домашней. А вот команда cd путь использует относительный путь. То есть мы можем перемещаться относительно той директории, в которой находимся. Введём команду в терминал cd ~/Desktop/. Прямой слэш после директории позволяет явно указать, что мы обращаемся к директории, а не к чему-то ещё с таким же названием.

Команда pwd позволяет узнать текущую директорию. Она нужна в основном для терминалов, которые не выводят подобную информацию. Такое редко бывает, но знать про эту команду нужно. Возможно, именно вам попадётся терминал, который не будет выводить текущую директорию.

Команда touch создаёт файлы.
После touch через пробел указывается название файла и его расширение, например info.txt

Команда ls показывает содержимое директории. Если не указывать дополнительные параметры, то содержимое будет выведено в неудобном формате.
Дополнительные параметры делают вывод более читабельным:

параметр -l (-list) выводит в столбик все вложенные директории. Также он показывает более подробную информацию о файлах и директориях. Например, когда и кем они созданы.
параметр -a (-all) показывает скрытые файлы.
Обычно оба параметра используют вместе, в итоге получается такая команда: ls -la

Команда cat позволяет просмотреть содержимое файла.

Команда rm удаляет указанный файл или директорию. После rm через пробел пишется файл или директория.
Важно: команда не перемещает удалённые объекты в корзину, а полностью их стирает. Будьте осторожны, если используете её.

Команда clear очищает терминал от вывода и введённых команд.

Некоторые терминалы при использовании команды clear лишь скрывают вывод из области видимости. Поэтому для 100% очищения разработчики могут использовать команду clear && clear.

Команда xdg-open открывает директории, файлы и приложения. Её удобно использовать, если вы, например, работаете без графического интерфейса или хотите запускать через терминал то, что вам нужно.

Данная команда работает на Linux. Если у вас операционная система Mac, можете использовать open, а на Windows есть похожая команда — start. Разница между ними только в названии, а всё, что будет после них записано, примерно одинаковое.
