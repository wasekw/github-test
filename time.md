Переходим в Git Bash и вводим команду ssh-keygen -t ed25519 -C "электронная почта". Вместо текста «электронная почта» нужно написать почту, которую вы указывали при регистрации на GitHub.
ssh-keygen -t ed25519 -C "volo
Введена команда ssh-keygen -t ed25519 -C
Нас уведомляют о том, что происходит генерация пары открытых и закрытых ключей ed25519. То есть началось создание SSH-ключа с использованием почты, которую мы указали в команде.

Далее нам предлагают указать файл, в котором будет храниться SSH-ключ, или нажать клавишу Enter для выбора значения по умолчанию. Выбираем второй вариант: если задавать пользовательское значение расположения и названия файла, в будущем могут появиться некоторые трудности.
Генерация SSH-ключа завершена. Нас также уведомили о том, что идентификационный файл и файл с публичным ключом сохранены в директории .ssh. Дополнительно нам показали случайное изображение, созданное на основе сгенерированного ключа.

Прейдём в директорию .ssh с помощью команды cd ~/.ssh/ и убедимся, что файлы действительно там появились.
Затем введём команду ls -la, чтобы вывести содержимое директории.

cd- повертає нас в ту директорию в якій ми були до цього
Можно было написать команду ls -la ~/.ssh/

скопируем публичный (открытый) SSH-ключ, чтобы позже вставить его в специальное поле на GitHub. Для этого воспользуемся командой clip < ~/.ssh/id_ed25519.pub

Дальше нам предлагают выбрать тип ключа: Authentication Key или Signing Key. Так как нам нужен тип Authentication Key, оставляем всё без изменений. С помощью SSH-ключа можно подписывать коммиты — если бы это было нам нужно, мы бы выбрали тип Signing Key.
В последнее текстовое поле Key вставляем скопированный ключ. После этого нажимаем на кнопку Add SSH key

Проверим SSH-соединение — убедимся, что в прошлом шаге мы всё сделали верно и у нас есть связь с GitHub. Для этого мы развернём Git Bash и введём команду ssh -T git@github.com.

Далее нам сообщат, что проверить подлинность хоста GitHub пока невозможно, и попросят подтвердить, что отпечаток SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU совпадает с отпечатком открытого ключа GitHub. Отпечаток открытого ключа GitHub для ed25519 — SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. Отпечатки совпадают, а это значит, мы можем ввести в Git Bash yes и нажать клавишу Enter.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

SSH-агент — это менеджер ключей, работающий с SSH. Он хранит закрытые ключи, которые затем используются для аутентификации. SSH-агент избавляет нас от постоянного ввода пароля. Его можно сравнить с менеджером паролей, который мы используем при входе на какой либо-веб-сайт.

Сначала введём команду eval "$(ssh-agent -s)", которая запускает SSH-агент.

Затем добавим закрытый ключ в SSH-агент с помощью команды ssh-add ~/.ssh/id_ed25519. Если при генерации пары ключей SSH вы указали другое название файла, укажите в команде путь до файла с закрытым ключом.

Настраиваем автоматический запуск SSH-агента

Закроем Git Bash и остановим процесс SSH-агента через диспетчер задач либо любым другим способом. Это нужно для того, чтобы вы увидели, как работает автоматический запуск SSH-агента. После перейдём в директорию пользователя и создадим в ней два файла. Первый с названием .bashrc, а второй — .bash_profile.

Далее откроем через любой редактор кода файл .bashrc

Затем вставим в него следующий код:

env=~/.ssh/agent.env

agent_load_env () { test -f "$env" && . "$env" >| /dev/null ; }

agent_start () {
(umask 077; ssh-agent >| "$env")
    . "$env" >| /dev/null ; }

agent_load_env

agent_run_state=$(ssh-add -l >| /dev/null 2>&1; echo $?)

if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then
agent_start
ssh-add
elif [ "$SSH_AUTH_SOCK" ] && [ $agent_run_state = 1 ]; then
ssh-add
fi

unset env

Сохраняем и закрываем файл. Теперь нужно открыть файл .bash_profile

Вставим код:

test -f ~/.profile && . ~/.profile
test -f ~/.bashrc && . ~/.bashrc

Код из файла .bashrc будет запускать SSH-агент, а код из файла .bash_profile будет запускать файл .bashrc.

Плюс данного способа: вам нужно ввести кодовую фразу только один раз при первом запуске Git Bash. После она не будет запрашиваться — и так до тех пор, пока вы не перезагрузите компьютер.

//==================================================================================================================//

Изменить кодовую фразу можно с помощью команды ssh-keygen -p -f ~/.ssh/id_ed25519. Если вы указали при генерации другое название файла, а не выбрали значение по умолчанию id_ed25519, то в команде нужно указать ваше название и путь (если он тоже изменён).

После ввода команды нас попросят ввести старую кодовую фразу. Введём её и нажмём клавишу Enter.

укажем новую кодовую фразу. Введём её и снова нажмём клавишу Enter.

//===================================================================================================================//

Изначально у GPG было другое название — G10, оно появилось благодаря десятой статье Конституции ФРГ. Суть этой статьи заключается в том, что тайна переписки, почтовая и телекоммуникационная тайна неприкосновенны. В Конституции РФ есть похожая статья, под номером 23. Всё это наводит на мысль, что в погоне за безопасностью и было разработано данное программное обеспечение. Также есть ещё два вида записи названия: GnuPG и развёрнутое GNU Privacy Guard.

Программа GPG создана немецким разработчиком Вернером Кохом.

Эти статусы помогают разработчикам понять, из какого источника поступают изменения: надёжного или ненадёжного. Например, когда установлен статус Unverified, нет гарантии, что это действительно вы сделали коммит, ведь ваши данные (почту и пароль от аккаунта) легко заполучить. А вот GPG-ключ получить проблематично, но именно он и позволяет установить ту самую подпись, которая связывает автора и коммит.

Для дополнительной безопасности администраторы репозитория могут даже включить опцию, которая проверяет, что поступающие на ветку коммиты были подписанными и проверенными.

По умолчанию до включения режима Vigilant mode, или режима бдительность, есть три статуса:

Verified — коммит подписан, подпись проверена.
Unverified — коммит подписан, но подпись не удалось проверить. Скорее всего, GitHub не может распознать подпись, так как она создана вручную или неспециализированным софтом. Это редкий статус, он появляется, если вы намеренно пытаетесь сделать что-то не так, как нужно.
Статуса нет, коммит не подписан.

Генерируем пару ключей GPG

Сгенерируем пару ключей GPG. Сначала развернём Git Bash и введём команду gpg --full-generate-key

Нас уведомляют, что будут созданы новая директория .gnupg в директории пользователя, а также файл с ключами в директории .gnupg. Далее нам предлагают выбрать тип ключа. Оставим значение по умолчанию — RSA and RSA, и нажмём клавишу Enter.

Затем нас просят указать размер ключа. В значении по умолчанию задан размер 3072 бит, но мы укажем 4096, а после нажмём клавишу Enter. Чем больше размер ключа, тем он устойчивее, а его дешифровка будет занимать больше времени.

Далее нас просят указать срок действия ключа. Выберем значение по умолчанию, то есть 0. Это означает, что ключ будет действовать неограниченное количество времени. Жмём Enter и идём дальше.0

. Вам нужно ввести своё имя пользователя. Лучше указать то, которое вы прописывали при настройке Git в команде git config --global user.name.

Далее укажем электронную почту, которая привязана к GitHub, и нажмём Enter.
Поле «Комментарий» можно пропустить или указать GitHub key — оно необязательное. Мы в него ничего не будем записывать, поэтому просто нажмём Enter

Добавляем GPG-ключ в аккаунт на GitHub

Сначала введём команду gpg --list-secret-keys --keyid-format=long.

Далее скопируем идентификатор GPG-ключа. В нашем случае он такой: B32440B423383E93. У вас он также будет в строке sec, но с другими символами. Затем введём ещё одну команду, позволяющую показать ключ для вставки в GitHub — gpg --armor --export B32440B423383E93. После --export вставьте свой идентификатор.

Появился очень длинный ключ. Он начинается с -----BEGIN PGP PUBLIC KEY BLOCK-----
и заканчивается на -----END PGP PUBLIC KEY BLOCK-----.
Скопируем его полностью вместе с этим текстом. После этого перейдём в GitHub и нажмём на мини-иконку профиля.

В поле Title укажите любое название для GPG-ключа. Это примерно такое же поле, как было при добавлении SSH-ключа. А в поле Key вставьте тот самый ключ, который был в Git Bash. После этого нажимаем на зелёную кнопку Add GPG key.

Добавляем GPG-ключ в глобальный конфигурационный файл Git

Git до сих пор не знает про GPG-ключ, поэтому нужно добавить наш ключ в глобальный конфигурационный файл. Возьмём ранее выведенный идентификатор GPG-ключа B32440B423383E93. Затем введём команду в Git Bash git config --global user.signingkey B32440B423383E93

Если вы захотите использовать приложение GitHub Desktop после настройки GPG, то столкнётесь с ошибкой, из-за которой у вас не получится подписать коммит. Всё дело в том, что изначально коммиты подписываются только через терминал и с использованием опции -S, а при использовании GitHub Desktop нельзя указать опцию. Поэтому в глобальном конфигурационном файле нужно явно указать программу GPG, которая будет вызываться при использовании приложения GitHub Desktop во время создания нового коммита.

Для начала определим путь, по которому расположена программа GPG. Для этого мы введём в Git Bash команду where gpg.

Далее скорректируем путь до программы на такой: C:/Program Files/Git/usr/bin/gpg.exe. То есть заменим обратные слэши на прямые, чтобы они не вызывали проблем.

Введём команду git config --global gpg.program "C:/Program Files/Git/usr/bin/gpg.exe"

Настраиваем подписание коммитов по умолчанию

Для подписания коммита нужно вводить опцию -S в команде git commit, но это не всегда удобно, да и про неё можно просто забыть. Поэтому сейчас мы включим подписание коммитов по умолчанию. Для этого пропишем в Git Bash команду git config --global commit.gpgsign true
